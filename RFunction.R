library('move')
library('sp')
library('sf')
library('ggplot2')
library('adehabitatLT')
library('geosphere')

# plans for changes: 
# 1. find crossings for each individual separately, make track into multiline (of each 2-pt segment) to have more control of when the crossing took place and have a correct timestamp and closest location (in time)
# 2. have legend indicate also colours black and orange
# 3. add background map (ggmap or leaflet)
# 4. option to get back fallback roads file (MoveApps feature)


rFunction <- function(data,colour_name=NULL,road_files=NULL)
{
  Sys.setenv(tz="UTC")
 
  #roads <- st_read("GRIP_roads_NASAY2Y/GRIP_roads_NASAY2Y.shp")
  roads <- st_read(paste0(getAppFilePath("road_files"),"roads.shp"))
  
  data_ltraj <- as(data,"ltraj")
  data_spdf <- ltraj2sldf(data_ltraj,byid=TRUE)
  
  data_sf <- st_as_sf(data_spdf)
  st_crs(data_sf) <- st_crs(roads)
  
  bb <- st_bbox(data_sf)
  roads_crop <- st_crop(roads,bb)
  
  crss <- st_intersection(roads_crop,data_sf) #for each road one feature with crossings
  dimcrss <- dim(crss)
  crss <- st_cast(crss,to="MULTIPOINT") #change object type,else error in merge() below
  
  if (dimcrss[1]==0) 
  {
    logger.info("There is no intersection of your track(s) with any road in the Y2Y region. Returning input data set.")
    result <- data
  } else
  {
    if (is.null(colour_name) | length(colour_name)==0 | colour_name %in% names(roads_crop)==FALSE)
    {
      logger.info("Your road colour name does not exist or has been chosen to be NULL. Therefore all roads have the same colour, not indicating road type or any other property.")
      
      map <- ggplot(roads_crop) + 
        geom_sf(colour=4,size=2) +
        geom_sf(data=data_sf,colour="black",aes()) +
        geom_sf(data=crss,aes(),colour="orange") +
        guides(colour = guide_legend(title = "Road property")) +
        ggtitle("Road intersections") +
        theme(plot.title = element_text(color="orange"))
    } else
    {
      eval(parse(text=paste0("class(roads_crop$",colour_name,") <- 'character'")))
      
      map <- ggplot() + 
        geom_sf(data=roads_crop,aes_string(col=colour_name),size=2) +
        geom_sf(data=data_sf,colour="black",aes()) +
        geom_sf(data=crss,aes(),colour="orange") +
        guides(colour = guide_legend(title = "Road property")) +
        ggtitle("Road intersections") +
        theme(plot.title = element_text(color="orange"))
    }
    
    crss_t <- st_transform(crss, crs(data)) #backtransform to crs of data
    
    crss_df <- data.frame("roadID"=1:dimcrss[1],data.frame(crss_t)[,1:(dimcrss[2]-1)])
    
    crss_detail <- merge(crss_df,st_coordinates(crss_t),by.x="roadID",by.y="L1")
    names(crss_detail)[names(crss_detail)=="id"] <- "trackId"
    names(crss_detail)[names(crss_detail)=="X"] <- "location.long"
    names(crss_detail)[names(crss_detail)=="Y"] <- "location.lat"
    
    # add timestamp when animal was closest to each intersection
    data.split <- move::split(data)
    
    len <- dim(crss_detail)[1]
    
    logger.info(paste("The algorithm has detected", len, "intersections of your tracks(s) with", dimcrss[1],"roads in the Y2Y region."))
    
    timestamp.near <- animalID <- species <- sensor <- character(len)
    long.near <- lat.near <- numeric(len)
    for (i in seq(along=crss_detail[,1])) #for each crossing point
    {
      #print(i)
      datai <- data.split[[which(names(data.split)==crss_detail$trackId[i])]]
      #dists2crssi <- distVincentyEllipsoid(coordinates(datai),crss_detail[i,c("location.long","location.lat")]) #takes too long
      dists2crssi <- distGeo(coordinates(datai),crss_detail[i,c("location.long","location.lat")]) #meter
      ixmin <- min(which(dists2crssi==min(dists2crssi)))
      timestamp.near[i] <- as.character(timestamps(datai)[ixmin]) #timestamp of location of this track that is closest to crossing
      loc_neari <- coordinates(datai)[ixmin,]
      long.near[i] <- loc_neari[1]
      lat.near[i] <- loc_neari[2]
      sensor[i] <- as.character(sensor(datai))[1]
      
      iddata <- idData(datai)
      names(iddata) <- make.names(names(iddata),allow_=FALSE)
      if (any(names(iddata)=="individual.taxon.canonical.name")) {
        species[i] <- iddata$individual.taxon.canonical.name[1]
      } else if (any(names(iddata)=="taxon.canonical.name")) {
        species[i] <- iddata$taxon.canonical.name[1]
      } else {
        species[i] <- NA
      }
      
      if (any(names(iddata)=="individual.local.identifier")) {
        animalID[i] <- iddata$individual.local.identifier[1]
      } else if (any(names(iddata)=="local.identifier")) {
        animalID[i] <- iddata$local.identifier[1]
      } else {
        animalID[i] <- NA
      }
    }
    
    crss_detail <- data.frame("roadID"=crss_detail[,1],animalID,crss_detail[,-1],timestamp.near,long.near,lat.near,species,sensor)
    
    write.csv(crss_detail,file=paste0(Sys.getenv(x = "APP_ARTIFACTS_DIR", "/tmp/"),"road_crossings_table.csv"),row.names=FALSE)
    ggsave(map, file = paste0(Sys.getenv(x = "APP_ARTIFACTS_DIR", "/tmp/"),"road_crossings_map.png"),width=8, height=8)
    
    zeit <- as.POSIXct(crss_detail$timestamp.near,tz="UTC") + c(1:len)
    o <- order(zeit)
    roadcross <- move(x=crss_detail$location.long[o],y=crss_detail$location.lat[o],time=zeit[o], data = crss_detail[o,], proj=projection(data))
    
    result <- moveStack(data,"road_crossing"=roadcross,forceTz="UTC")
  } 
  
  
  return(result)
}

